package genericos; // Se define el paquete 'genericos'

import java.util.*; // Se importan las utilidades necesarias

public class UtilGenerico {

    /**
     * Método genérico que cuenta el número de elementos únicos (no repetidos)
     * que existen en dos colecciones dadas.
     *
     * @param <T> El tipo de elementos en las colecciones.
     * @param coleccion1 La primera colección.
     * @param coleccion2 La segunda colección.
     * @return El número de elementos únicos que se encuentran en ambas colecciones.
     */
    public static <T> int contarCoincidencias(Collection<T> coleccion1, Collection<T> coleccion2) {
        // Un HashSet es ideal para almacenar elementos únicos, ya que no permite duplicados.
        Set<T> elementosUnicos = new HashSet<>();

        // Se añaden todos los elementos de la primera colección al conjunto.
        elementosUnicos.addAll(coleccion1);
        // Se añaden todos los elementos de la segunda colección.
        // Los duplicados ya existentes en el conjunto no se añadirán de nuevo.
        elementosUnicos.addAll(coleccion2);

        // El tamaño del conjunto representa el número de elementos únicos.
        return elementosUnicos.size();
    }

    /**
     * Método genérico que invierte un Map, transformando los valores originales en claves
     * y las claves originales (agrupadas en una lista) en valores.
     *
     * @param <K> El tipo de las claves originales del mapa.
     * @param <V> El tipo de los valores originales del mapa.
     * @param mapaOriginal El mapa a invertir.
     * @return Un nuevo Map donde las claves son los valores originales del mapa sin repetir,
     * y los valores son listas de las claves originales asociadas a ese valor.
     */
    public static <K, V> Map<V, List<K>> invertirOrden(Map<K, V> mapaOriginal) {
        Map<V, List<K>> mapaInvertido = new HashMap<>();

        // Se itera sobre cada entrada (clave-valor) del mapa original.
        for (Map.Entry<K, V> entrada : mapaOriginal.entrySet()) {
            K claveOriginal = entrada.getKey();   // Se obtiene la clave original.
            V valorOriginal = entrada.getValue(); // Se obtiene el valor original.

            // Se verifica si el valor original (que será la nueva clave) ya existe en el mapa invertido.
            // Si no existe, se crea una nueva lista vacía para asociarla.
            mapaInvertido.computeIfAbsent(valorOriginal, k -> new ArrayList<>())
                         .add(claveOriginal); // Se añade la clave original a la lista.
        }
        return mapaInvertido;
    }

    public static void main(String[] args) {
        // --- PRUEBAS PARA contarCoincidencias ---
        System.out.println("--- Pruebas para contarCoincidencias ---");

        List<Integer> lista1 = Arrays.asList(1, 2, 3, 4, 5);
        List<Integer> lista2 = Arrays.asList(4, 5, 6, 7, 8);
        int coincidencias1 = contarCoincidencias(lista1, lista2);
        System.out.println("Lista 1: " + lista1 + ", Lista 2: " + lista2);
        System.out.println("Elementos únicos: " + coincidencias1); // Debería ser 8 (1,2,3,4,5,6,7,8)

        Set<String> set1 = new HashSet<>(Arrays.asList("manzana", "pera", "uva"));
        Set<String> set2 = new HashSet<>(Arrays.asList("pera", "kiwi", "manzana"));
        int coincidencias2 = contarCoincidencias(set1, set2);
        System.out.println("Set 1: " + set1 + ", Set 2: " + set2);
        System.out.println("Elementos únicos: " + coincidencias2); // Debería ser 4 (manzana,pera,uva,kiwi)

        List<Double> listaMixta1 = Arrays.asList(1.1, 2.2, 3.3);
        List<Double> listaMixta2 = Arrays.asList(3.3, 4.4, 5.5);
        int coincidencias3 = contarCoincidencias(listaMixta1, listaMixta2);
        System.out.println("Lista Mixta 1: " + listaMixta1 + ", Lista Mixta 2: " + listaMixta2);
        System.out.println("Elementos únicos: " + coincidencias3); // Debería ser 5 (1.1,2.2,3.3,4.4,5.5)

        System.out.println("\n--- Pruebas para invertirOrden ---");

        // --- PRUEBAS PARA invertirOrden ---
        Map<String, String> mapaEjemplo = new HashMap<>();
        mapaEjemplo.put("1", "a");
        mapaEjemplo.put("2", "b");
        mapaEjemplo.put("3", "a");
        Map<String, List<String>> mapaInvertidoEjemplo = invertirOrden(mapaEjemplo);
        System.out.println("Mapa original: " + mapaEjemplo);
        System.out.println("Mapa invertido: " + mapaInvertidoEjemplo); // Debería ser {a=[1, 3], b=[2]}

        Map<Integer, String> mapaNumeros = new HashMap<>();
        mapaNumeros.put(10, "Diez");
        mapaNumeros.put(20, "Veinte");
        mapaNumeros.put(30, "Diez");
        mapaNumeros.put(40, "Treinta");
        Map<String, List<Integer>> mapaInvertidoNumeros = invertirOrden(mapaNumeros);
        System.out.println("Mapa original: " + mapaNumeros);
        System.out.println("Mapa invertido: " + mapaInvertidoNumeros); // Debería ser {Treinta=[40], Diez=[10, 30], Veinte=[20]}

        Map<Boolean, Integer> mapaBooleanos = new HashMap<>();
        mapaBooleanos.put(true, 1);
        mapaBooleanos.put(false, 0);
        mapaBooleanos.put(true, 5); // Sobrescribe la entrada anterior para 'true' si la clave ya existe
        Map<Integer, List<Boolean>> mapaInvertidoBooleanos = invertirOrden(mapaBooleanos);
        System.out.println("Mapa original: " + mapaBooleanos);
        System.out.println("Mapa invertido: " + mapaInvertidoBooleanos); // Dependerá del último valor asociado a 'true'
                                                                         // Si se mantiene la clave única, entonces {0=[false], 5=[true]}
                                                                         // Si se permiten duplicados (no es el caso de HashMap), sería {0=[false], 1=[true], 5=[true]}
                                                                         // En un HashMap, put(true, 5) reemplaza put(true, 1), por lo que el mapa original será {true=5, false=0}
                                                                         // Y el invertido {0=[false], 5=[true]}
    }
}
